# 高度，深度，层数

节点n的高度：n节点到叶子节点所有路径上包含节点个数的最大值。叶子节点的高度为1，往上依次递增。

节点n的深度：从根节点到n节点唯一路径的长，根节点的深度为1。（有的标准为0，两种记法都没错）

层数：根节点为第一层，往下依次递增。

节点的度：节点拥有的子树的个数，度为0的节点称为叶子节点。



树的度：树中节点的最大的度。

树的高度：树中节点的最大层数。

树的深度：树中节点的最大层数。（假设深度基数为1）



# 红黑树

 https://juejin.im/post/5d9fbd72e51d45781a677c87 

 https://tech.meituan.com/2016/12/02/redblack-tree.html 



1. 每个节点标记为红色或黑色。
2. 根是黑色。
3. 如果一个节点是红色的，那么它的子节点必须是黑色（这就是为什么叫**红黑树**）。
4. 一个节点到一个 null 引用的每一条路径必须包含相同数目的黑色节点（所以红色节点不影响）。
5. 叶子节点有两个 null 引用作为子节点。
6. 新加入的节点为红色。



RB Tree 其实是实现 AVL Tree 的一种方法/规则。

为了维持树的高度，必须在插入一个节点后对树的结构进行调整，通过旋转。



### 为什么要进行旋转？

调整树的结构，以满足红黑树的规则（红节点下面的节点必须为黑色节点），以实现树的平衡。



### 新加入的节点总是红色的，这是为什么呢？

因为被插入前的树结构是构建好的，一但我们进行添加黑色的节点，无论添加在哪里都会破坏原有路径上的黑色节点的数量平等关系，所以插入红色节点是正确的选择。



### 为什么要进行颜色变换？

正如第一种旋转新加入的节点X破坏了红黑树的结构不得不进行旋转，后面的就是旋转后的结果，旋转后形成新的结构，此时我们发现两个子节点都是红色的所以执行第三个变换特性，颜色变换，因为如果子节点是红色的那么我们在添加的时候只能添加黑色的节点，然而添加任何黑色叶子节点都会破坏树的第四条性质，所以要对其进行变换。当进行变换后叶子节点是红色的而且我们默认添加的叶子节点是红色的，所以添加到黑色节点后并不会破坏树的第四条结构，所以这种变换很有用。

第二种双变换中在树的内部怎么出现的红色的节点？ 正是由于上面的颜色变换导致新颜色变换后的节点与他的父节点产生了颜色冲突。

与AVL树相比？ 比AVL树相比优点是不用在节点类中保存一个节点高度这个变量，节省了内存。

而且红黑树一般不是以递归方式实现的而是以循环的形式实现。

一般的操作在最坏情形下花费O（logN）时间。



## 总结

作为平衡二叉查找树里面众多的实现之一，红黑树无疑是最简洁、实现最为简单的。红黑树通过引入颜色的概念，通过颜色这个约束条件的使用来保持树的高度平衡。作为平衡二叉查找树，旋转是一个必不可少的操作。通过旋转可以降低树的高度，在红黑树里面还可以转换颜色。

红黑树里面的插入和删除的操作比较难理解，这时要注意记住一点：操作之前红黑树是平衡的，颜色是符合定义的。在操作的时候就需要向兄弟节点、父节点、侄子节点借调和互换颜色，要达到这个目的，就需要不断的进行旋转。所以红黑树的插入删除操作需要不停的旋转，一旦借调了别的节点，删除和插入的节点就会达到局部的平衡（局部符合红黑树的定义），但是被借调的节点就不会平衡了，这时就需要以被借调的节点为起点继续进行调整，直到整棵树都是平衡的。在整个修复的过程中，插入具体的分为3种情况，删除分为4种情况。

整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从叶到根的，所以经过的路径都是logN。







































