## 1. JVM内存区域

画图

并说明永久代的发展历史

堆（新生代、老年代）

栈（虚拟机栈，本地方法栈、程序计数器）

方法区：1.7前，永久代（运行时常量池、字符串常量池、类的元数据）

1.7，字符串常量池放到堆中

1.8后 元数据区metaspace（运行时常量池、类的元数据）



区域参数调优：

默认情况下，老年代是新生代的 2 倍大



## 2.类加载过程

**加载**阶段（Loading）：从各种数据源中读取字节码到JVM并生成 **方法区的运行时数据结构**。（堆的Class对象，入口方法区）

它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。

**验证**（Verification）：**校验是否符合JVM规范**，防止恶意信息危害。文件格式验证，元数据验证，字节码验证，符号引用验证。

这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。

**内存分配** 准备（Preparation）：给**方法区中静态变量分配内存**。

创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。

方法区中对类的static变量分配内存并设置类变量数据类型默认的初始值，不包括实例变量，实例变量将会在对象实例化的时候随着对象一起分配在Java堆中



**解析**（Resolution）：将**常量池的符号引用改为直接引用**

在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在Java 虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。



**初始化**阶段（initialization）：为**静态变量赋代码初始值，执行静态块**的逻辑。

这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。







**双亲委派模型**：类加载器加载类时，先给父加载器加载。避免重复加载类。

简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。

双亲委派机制过程：

（1）：类加载器收到类加载的请求

（2）：把这个请求委托给父加载器去完成，一直向上委托，直到启动类加载器

（3）：启动器加载器检查能不能加载，能就加载（结束）；否则，抛出异常，通知子加载器进行加载

（4）：保障类的唯一性和安全性以及保证JDK核心类的优先加载



加载器类型：

1. **启动**类加载器：加载JVM核心类库。如java.lang.*等
2. **扩展**类加载器：从jre/lib/ext下加载类库
3. **应用程序** 类加载器：从环境变量中加载（用户classpath路径）



如何打破双亲委派模型？

**自定义类加载器**：继承ClassLoader类重写loadClass方法。



因为 **基础代码无法调用用户代码**，所以：

JNDI，JDBC 利用**线程上下文类加载器**，父类加载器请求子类加载器去完成类加载。





对象的构成：

**对象头**：主要是包括两部分，1.存储自身的运行时数据比如**hash码，分代年龄，锁标记**等（但是不是绝对哦，锁状态如果是偏向锁，轻量级锁，是没有hash码的。。。是不固定的）2.指向类的元数据指针。还有可能存在第三部分，那就是数组类型，会多一块记录数组的长度（因为数组的长度是jvm判断不出来的，jvm只有元数据信息）

**实例数据**：会根据虚拟机分配策略来定，分配策略中，会把相同大小的类型放在一起，并按照定义顺序排列（父类的变量也会在哦）

**对齐填充**：这个意义不是很大，主要在虚拟机规范中对象必须是8字节的整数，所以当对象不满足这个情况时，就会用占位符填充













## 3.GC



JDK 9 的默认 GC 是 G1，虽然它在较大堆场景表现良好，但本身就会比传统的 Parallel GC 或者 Serial GC 之类复杂太多，所以要么降低其并行线程数目，要么直接切换 GC 类型；

JIT 编译默认是开启了 TieredCompilation 的，将其关闭，那么 JIT 也会变得简单，相应本地线程也会减少。



各种 GC 和算法：

**Serial** ：收集工作是**单线程**的，GC时Stop-The-World，但使用精简。

**Serial Old**，它采用了**标记 - 整理**（Mark-Compact）算法，区别于新生代的**复制算法**。

**ParNew GC**，很明显是个新生代 GC 实现，它实际是 **Serial  的多线程版本**，最常见的应用场景是配合老年代的 CMS GC 工作，下面是对应参数

**CMS GC**，基于**标记 - 清除（Mark-Sweep）算法**，设计目标是尽量减少停顿时间，这一点对于 Web 等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用 CMS GC。但是，CMS 采用的标记 - 清除算法，存在着**内存碎片化问题**，所以难以避免在长时间运行等情况下**发生 full GC**，导致恶劣的停顿。另外，既然强调了并发（Concurrent），CMS 会占用更多 CPU 资源，并和用户线程争抢。

因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但是已经被标记为废弃，如果没有组织主动承担 CMS 的维护，很有可能会在未来版本移除。

**Parallel** GC，在早期 **JDK 8** 等版本中，它是 server 模式 JVM 的默认 GC 选择，也被称作是吞吐量优先的 GC。它的算法和 Serial GC 比较相似，尽管实现要复杂的多，其特点是**新生代和老年代 GC 都是并行进行**的，在常见的服务器环境中更加高效。

**G1 GC** 这是一种兼顾吞吐量和停顿时间的 GC 实现，是 Oracle **JDK 9** 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。

G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 region。Region 之间是复制算法，但整体上实际可看作是**标记 - 整理（Mark-Compact）算法**，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。

分代，分区复制，标记整理。

**ZGC**（http://openjdk.java.net/jeps/333），这是 Oracle 开源出来的一个超级 GC 实现，具备令人惊讶的扩展能力，比如支持 T bytes 级别的堆大小，并且保证绝大部分情况下，延迟都不会超过 10 ms。虽然目前还处于实验阶段，仅支持 Linux 64 位的平台，但其已经表现出的能力和潜力都非常令人期待。



三种 GC算法：

**复制**（Copying）算法：新生代 GC，基本都是基于复制算法。复制活对象，并按顺序放置避免碎片化。但是要预留空间消耗内存。

将活着的对象复制到 to 区域，拷贝过程中将对象顺序放置，就可以避免内存碎片化。这么做的代价是，既然要进行复制，既要提前预留内存空间，有一定的浪费；另外，对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，这个开销也不小，不管是内存占用或者时间开销。

**标记 - 清除**（Mark-Sweep）算法，首先进行标记工作，**标识出所有要回收的对象，然后进行清除**。这么做除了标记、清除过程效率有限，另外就是不可避免的出现**碎片化问题**，这就导致其不适合特别大的堆；否则，一旦出现 Full GC，暂停时间可能根本无法接受。

**标记 - 整理**（Mark-Compact），类似于标记 - 清除，它会在**清理过程中将对象移动**，避免内存碎片化，以确保移动后的对象占用连续的内存空间。



GC 形式：

在 Eden 区域分配，在⼀次新⽣代垃圾回收后，如果对象还存活，则会进⼊ s0 或者 s1，并且对象的
年龄还会加 1(Eden区i>Survivor 区后对象的初始年龄变为1)，当它的年龄增加到⼀定程度（默认为15
岁），就会被晋升到⽼年代中。对象晋升到⽼年代的年龄阈值，可以通过参数 -
XX:MaxTenuringThreshold 来设置。
另外，⼤对象和⻓期存活的对象会直接进⼊⽼年代  



新⽣代GC（Minor GC） :指发⽣新⽣代的的垃圾收集动作， Minor GC⾮常频繁，回收速度比较快。
⽼年代GC（Major GC/Full GC） :指发⽣在⽼年代的GC，出现了Major GC经常会伴随⾄少⼀次的
Minor GC（并⾮绝对）， Major GC的速度⼀般会⽐Minor GC的慢10倍以上。  

回收新生代、老年代、metaspace。



判断对象是否需要被回收：

可达性分析算法
这个算法的基本思想就是通过⼀系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，
节点所⾛过的路径称为引⽤链，当⼀个对象到 GC Roots 没有任何引⽤链相连的话，则证明此对象是不
可⽤的。  

**GC Roots**：虚拟机栈的引用对象、本地方法栈的引用对象、方法区类变量的引用对象、方法区常量的引用。



## 4.调优和线上问题解决

**jmap** dump内存快照查看。

配置HeapDumpOnOutOfMemoryrror 自动dump

jhat 分析。

**jstack**可以定位到某个线程堆栈。ps找出耗费cpu的线程id。

找出该进程内最耗费CPU的线程，可以使用ps -Lfp pid或者ps -mp pid -o THREAD, tid, time或者top -Hp pid

**jstat** 查看jvm内存。FGC这个参数很大，说明fullGC进行的很频繁，而且FGCT也就是fullGC总的耗时时间很长。

JConsole 图形化查看常见的**堆内存**和**各种堆外部分**使用状态。



fullgc 频繁，old回收率不大，old区太小，设置大一点。如果回收后old对象不多，说明 eden区太小，导致短生命的对象进入old。

堆内存不足是最常见的 OOM 原因之一。





处理GC日志：

```text
-XX:+PrintGCDetails 
-XX:+PrintGCDateStamps 
-Xloggc:/home/GCEASY/gc-%t.log
```

为什么不推荐启用UseGCLogFileRotation来记录GC日志？ - 若鱼1919的文章 - 知乎 https://zhuanlan.zhihu.com/p/71221926



https://zhuanlan.zhihu.com/p/58461333

你有哪些面试失败的惨痛经验？ - 乔戈里的回答 - 知乎 https://www.zhihu.com/question/290543744/answer/610954201





### 关于 MinorGC、MajorGC、FullGC（待整理）

**Parallel Scavenge 收集器下，默认是在要触发 full GC前先执行一次 young GC**,并且两次GC之间能让应用程序稍微运行一小下，以期降低 full GC的暂停时间 (因为 young GC 会尽量清理了young gen的死对象，减少了 full GC的工作量)。**控制这个行为的VM参数是: -XX:+ScavengeBeforeFullGC**。



**当新生代的Eden区满的时候触发 Minor GC**

当发生 Minor GC时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制(此处采用标记 - 复制算法)到 to 指向的 Survivor区中，然后**交换 from 和 to指针，以保证下一次 Minor GC时，to 指向的 Survivor区还是空的**。

> Java虚拟机会记录 Survivor区中的对象一共被来回复制了几次。**如果一个对象被复制的次数为 15 (对应虚拟机参数 -XX:+MaxTenuringThreshold),那么该对象将被晋升为至老年代**，(至于为什么是 15次，原因是 HotSpot会在对象头的中的标记字段里记录年龄，分配到的空间只有4位，所以最多只能记录到15)。另外，**如果单个 Survivor 区已经被占用了 50% (对应虚拟机参数: -XX:TargetSurvivorRatio)，那么较高复制次数的对象也会被晋升至老年代。**

**当Survivor区的部分对象晋升到老年代后，老年代的占用量通常会升高。**

**注意**：

在Minor GC过程中，Survivor 可能不足以容纳Eden和另一个Survivor中的存活对象。如果Survivor中的存活对象溢出，多余的对象将被移到老年代，这称为**过早提升(Premature Promotion)**，这会导致老年代中短期存活对象的增长，可能会引发严重的性能问题。再进一步说，在Minor GC过程中，如果老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC,这将导致遍历整个Java堆，这称为**提升失败(Promotion Failure)**。


**Full GC 就是收集整个堆，包括新生代，老年代，永久代(在JDK 1.8及以后，永久代会被移除，换为metaspace)等收集所有部分的模式**



- Young GC: 只收集young gen的GC，**"Minor GC"**
- Old GC: 只收集old gen的GC。只有垃圾收集器CMS的concurrent collection 是这个模式
- Mixed GC: 收集整个young gen 以及部分old gen的GC。只有垃圾收集器 G1有这个模式

**Full GC**: 收集整个堆，包括 新生代，老年代，永久代(在 JDK 1.8及以后，永久代被移除，换为metaspace 元空间)等所有部分的模式



Full GC的触发条件

针对不同的垃圾收集器，Full GC的触发条件可能不都一样。**按HotSpot VM的serial GC的实现来看**，触发条件是:

- > **当准备要触发一次 young GC时，如果发现统计数据说之前 young GC的平均晋升大小比目前的 old gen剩余的空间大，则不会触发young GC而是转为触发 full GC** (因为HotSpot VM的GC里，除了垃圾回收器 CMS的concurrent collection 之外，其他能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先准备一次单独的young GC)

- > **如果有永久代(perm gen),要在永久代分配空间但已经没有足够空间时，也要触发一次 full GC**

- > **System.gc()，heap dump带GC,其默认都是触发 full GC.**





参考资料

一文搞清楚Minor GC、Major GC 、Full GC 之间的关系：
https://juejin.im/post/6844903967172853767

JVM 系列文章之 Full GC 和 Minor GC（推荐）：

https://juejin.im/post/6844903669251440653



蚂蚁大佬 spark 的metaspace触发 fullgc

https://juejin.im/post/6850418116737351693







### JVM种类

**1.Sun Classic VM**

```
1.现在此款虚拟机已经淘汰了，是第一款商用的虚拟机。
2.只能使用纯解释器的方式来执行Java代码。
```

**2.HotSpot VM**

```
HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代
码，然后通知JIT编译器以方法为单位进行编译。 如果一个方法被频繁调用，或方法中有效
循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。 通过编译器与解释器
恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待
本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码
优化技术，输出质量更高的本地代码
```

**3.JRockit**

```
1.JRockit VM曾经号称“世界上速度最快的Java虚拟机”
2.由于专注于服务器端应用，它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时
编译器编译后执行。 除此之外，JRockit的垃圾收集器和MissionControl服务套件等部分的实
现，在众多Java虚拟机中也一直处于领先水平
```

**4.Microsoft JVM**

```
1.微软公司为了在IE3中支持Java Applets应用而开发了自己的Java虚拟机，虽然这款虚拟机只有Windows平台的版本，却
是当时Windows下性能最好的Java虚拟机。
```



参考资料：

https://blog.csdn.net/weishuai528/article/details/89885626



### 关于 直接引用 和 符号引用

符号引用：只包含语义信息，不涉及具体实现。

直接引用：与具体实现相关。

类、接口、方法和字段

例如：

引用的是 对象的字段：对象地址+偏移量

引用的是 类的静态变量：类的Class对象+偏移量



JDK 7或之后的HotSpot VM里：

```text
Java object      InstanceKlass       Java mirror
 [ _mark  ]                          (java.lang.Class instance)
 [ _klass ] --> [ ...          ] <-\              
 [ fields ]     [ _java_mirror ] --+> [ _mark   ]
                [ ...          ]   |  [ _klass  ]
                                   |  [ fields  ]
                                    \ [ klass   ]
                                      [ A.value ]
```



对象（klass） ->  类的元数据（java_mirror）<=> （klass）类的 Class对象

​	堆						方法区（元数据区(本地内存)）						堆



参考资料：

JVM符号引用转换直接引用的过程? - RednaxelaFX的回答 - 知乎 https://www.zhihu.com/question/50258991/answer/120450561





### 关于类加载时机

没有规定类加载的时机，但是初始化有严格规定。并且在初始化前，加载、验证、分配内存、解析都已完成。

类初始化的时机：

1. new, getstatic, putstatic, invokestatic 四个字节码指令
   - new 创建对象
   - get、set 一个类的静态字段（final 静态常量和常量池已有的静态字段不会触发初始化）
   - 调用类的静态方法
2. 使用 java.lang.reflect 包 **反射调用类**
3. 初始化一个类时，**父类未初始化**，则触发父类的初始化
4. 虚拟机启动时，**初始化主类**
5. jdk1.7 动态语言（待拓展）



上述五种方式称为 主动引用。



其他不会触发初始化的，叫 被动引用。

例子：

1. 通过子类引用**父类的静态字段**，不会导致子类初始化

   `SonClass.value` 

2. 通过类**调用常量**

   `CommonClass.staticFinalVal`

参考资料：https://juejin.im/post/6844903732409270286



### 关于 JVM区域的作用和 存放的内容

线程有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。

#### 栈：（线程自己的）

##### 虚拟机栈：

描述一个Java方法的内存模型。

栈帧：方法执行对应 栈帧的入栈出栈

栈顶的栈帧 称为当前栈帧，关联的方法称为当前方法。

编译时确定多大的局部变量表，多深的操作数栈。

局部变量表，操作数栈，动态连接，方法返回地址



动态连接：指向运行时常量池，关联方法的引用。



方法返回地址：

正常

异常





##### 本地方法栈：

为本地方法服务

栈深度溢出 StackOverflowError 和 栈扩展失败 OOM



##### 程序计数器：

通过计数器选取下一条字节码。

线程执行的字节码的行号/地址。

（虚拟机方法：虚拟机字节码的地址）

（本地方法：空）



#### 堆：（共享）

新生代，老年代

对象

对象头：1.hash码、分代年龄、锁标记 2.类的元数据的指针

实例数据

对齐填充





#### 元数据区：（共享）

类的信息：版本、字段、方法、接口

运行时常量池



堆外内存：

本机直接内存分配不受 JVM限制。







关于栈帧的详细资料：

https://juejin.im/post/6844903983400632327

https://juejin.im/post/6847902224291790862#heading-0





















