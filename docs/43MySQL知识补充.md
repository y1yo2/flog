

## 索引

### 索引类型

##### 普通索引：

最基本，没有唯一性等限制。

如果是字符串字段，可以指定索引长度。（为什么呢？）



##### 主键索引：

主键是一种唯一性索引，每个表只能有一个主键。

单表查询时，主键索引与唯一索引的效率相当。关联查询时，主键索引的速度较快。（为什么呢？）



##### 唯一索引：

索引字段的值必须是唯一的。



##### 全文索引：

只有**char、varchar，text** 列上可以创建全文索引，配合**match against**，加速查找文本。

MySQL 5.6前,只有MyISAM存储引擎支持全文索引。

5.6版本中，InnoDB支持全文索引，但是不支持中文全文索引。

5.7.6版本，内置ngram全文解析器，支持亚洲语种的分词。

通过建立**倒排索引**,可以极大的提升检索效率。（类似搜索引擎）

MySQL经典问题解答——一文解决Mysql全文索引的使用 - 大黄蜂的文章 - 知乎 https://zhuanlan.zhihu.com/p/77758968



对于大规模数据集，通过ALTER TABLE（或CREATE INDEX）**创建全文索引**比把记录插入带有全文索引的空表更快。



##### 组合索引：

包含多个字段的索引。

最左前缀匹配，最左优先，在检索数据时从联合索引的最左边开始匹配。

所以创建了一个联合索引，如(key1, key2, key3) ，相当于创建了(key1)、(key1, key2)、(key1, key2, key3)三个索引。



### 索引结构

#### Hash

哈希索引是采用**哈希算法**，把键值换算成新的哈希值，检索时只需**一次哈希算法**就可**定位到相应的位置**。

缺点是：

1. 哈希索引无法利用索引完成**排序**
2. 不支持联合索引的**最左匹配规则**
3. 有大量重复键值情况下，哈希索引的效率也极低。
   1. **哈希碰撞**问题
   2. **键值不唯一时**，先找到该键的位置，再**根据链表扫描**，找到相应数据
4. **不支持范围查询**



#### B+Tree

##### B树和B+树的区别

B树：

1. 多路非二叉树
2. 每个节点既保存索引，又保存数据
3. 搜索时相当于二分查找

B+树：

1. 多路非二叉树
2. 只在叶子节点保存数据
3. 搜索时相当于二分查找
4. 增加了相邻节点的指向指针

所以，主要区别是**数据保存位置，和相邻节点的指针**。



**B树和B+树区别：**

1. B+树查询时间复杂度固定是O(logn)，B树查询复杂度最好是O(1)，最差是O(logn)

2. B+树相邻节点的指针，增加区间访问性，可使用范围查询。

   空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。

   B+树利用局部性原理，若访问节点 50，则55、60、62节点也会**利用磁盘预读原理提前将这些数据读入内存，减少了磁盘 IO 的次数**。

3. **B树节点即保存数据又保存索引，查询磁盘IO的次数很少。B+树查询磁盘IO多，但区间访问好。**

4. B+树适合外部存储，即磁盘存储。只有叶子节点，每个节点的索引范围更大更精确。



##### MongoDB 和 Mysql：

`Mongo` 的主要场景是获取**单个元素**（`document`），`MySQL` 的主场景是获取**一批元素**（row或者index）。

前者对存储的要求是精确定位，尽量减少存储层次。后者则更依赖链接多条记录的指针。



参考资料：

https://zhuanlan.zhihu.com/p/102628897  为什么 MongoDB 索引选择B树，而 Mysql 选择B+树（精干总结）



#### InnoDB引擎支持什么索引？

| Storage Engine | Permissible Index Types |
| -------------- | ----------------------- |
| InnoDB         | BTREE                   |
| MyISAM         | BTREE                   |
| MEMORY/HEAP    | HASH, BTREE             |
| NDB            | H                       |

官方给出的解释是：

InnoDB utilizes hash indexes internally for its Adaptive Hash Index feature。

InnoDB 通过自适应的 hash索引 特性，在内部使用 hash索引。

InnoDB 的 hash索引 是自适应的。根据表的情况自动为表生成 hash索引，不能人为选择 hash索引。



#### TODO: 存储引擎的介绍

https://www.jianshu.com/p/ba1fbe96257b



### 索引优化建议

1. 常用条件字段（经常作为where条件的字段）建立索引
2. 根据业务建立组合索引
3. join对称建立索引，例如：A表的ID建立了索引，B表的AID也应该建立索引





### 问答扩展知识

> 面试官：你知道B+ Tree的叶子节点都可以存哪些东西吗？

我：InnoDB 的B+Tree可能存储的是整行数据，也有可能是主键的值。

InnoDB 里，B+Tree的叶子节点存储了整行数据的是**主键索引**，也叫**聚簇索引**。

B+Tree的叶子节点存储了主键值的是**非主键索引**，也叫**非聚簇索引**。



> 面试官：聚簇索引和非聚簇索引，在查询数据时有区别吗？

主键索引的叶子节点是整行数据。

非主键索引的叶子节点是主键值，还要通过主键值再进行一次查询，也叫**回表查询**。



> 面试官：所有情况都是这样的吗？非主键索引一定会查询多次吗？

因为非聚簇索引，叶子节点存储的是 主键+列值，所以当 **查询的列和索引是对应的**，不需要回表。这种创建多列索引的方法就是 **覆盖索引**。



TODO: 索引树的概念



> 面试官：那你们在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？

一般是把选择性最高的放左边，但也要兼顾到排序的效率。



> 面试官：那你知道最左前缀匹配吗？

创建组合索引时，我们会把 **where中使用最频繁的一列放在最左边**。因为 MySQL 会遵循最左前缀匹配原则，即**最左优先，在检索数据时从组合索引的最左列开始匹配**。

所以创建一个组合索引时，如(key1,key2,key3)，相当于创建了(key1)、(key1,key2)和(key1,key2,key3)三个索引。



> 面试官：那你知道在MySQL 5.6中，对索引做了哪些优化吗？

**索引下推**（Index Condition Pushdown (ICP) ）是MySQL5.6添加的，用于优化数据查询，默认开启。

使用 `SET optimizer_switch = ‘index_condition_pushdown=off’;` 可以将其关闭。

**不使用索引条件下推的查询过程**
获取下一行，首先读取索引，根据索引读取整行。

然后通过where条件判断是否接受或拒绝该行数据。

**使用索引条件下推优化时的查询过程**
获取下一行，首先读取索引，根据索引读取索引树的叶子节点。

根据叶子节点测试一部分适用的WHERE条件，满足条件再读取整行。

官方例子：people表中（zipcode，lastname，firstname）构成一个索引

```mysql
SELECT * FROM people 
WHERE zipcode=‘95054’ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;
```

如果没有使用索引下推，则`zipcode='95054’`会用到索引，从存储引擎中查询对应的数据，返回到MySQL服务端，然后 MySQL服务端基于`lastname LIKE '%etrunia%'`和`address LIKE '%Main Street%'`来过滤数据。

如果使用索引下推，则通过`zipcode='95054’`**查出索引树的叶子节点**，根据`lastname LIKE '%etrunia%'` **筛选出符合条件的叶子节点，再回表读取整行数据**返回给 MySQL服务端。然后MySQL服务端基于`address LIKE '%Main Street%'`判断数据。

这样返回给MySQL服务端的数据会减少。在有like条件查询的情况下，减少回表次数。



参考资料：https://juejin.im/post/5deef343e51d455819022033



> 面试官：那排查的时候，有什么手段可以知道有没有走索引查询呢？

通过**explain查看sql语句的执行计划**，通过执行计划来分析索引使用情况

> 面试官：什么情况下明明创建了索引，但是执行的时候并没有通过索引呢？

**查询优化器：**

查询语句经过解析器形成解析树，解析树经过优化器转化为执行计划（查询计划）。

查询优化器会找出所有可能的查询方案，对比找出成本最低的方案形成执行计划。

优化过程是：1. 根据搜索条件，找出所有可能使用的索引；

2. 计算全表扫描的代价；
3. 计算使用不同索引时查询的代价；
4. 对比各种执行方案的代价，选择成本最低的一个；





参考资料：

https://zhuanlan.zhihu.com/p/73204847















